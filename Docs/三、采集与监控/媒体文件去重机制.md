# 媒体文件去重机制

## 概述
媒体文件去重机制是采集系统的核心功能之一，通过多层筛选确保只下载高质量且未重复的媒体文件，提高采集效率并节省存储空间。

## 筛选机制架构

### 三层筛选体系
```
原始媒体URL → 基础去重 → 尺寸筛选 → 本地去重 → 最终下载列表
```

## 第一层：基础去重

### Set数据结构去重
**实现位置**：MediaManager.js
```javascript
class MediaManager {
    constructor() {
        this.collectedImages = new Set();  // 图片URL集合
        this.collectedVideos = new Set();  // 视频URL集合
    }
}
```

**去重原理**：
- 使用Set数据结构自动去除重复URL
- 基于严格相等比较（===）进行去重
- 在收集阶段即时去重，避免重复处理

**收集过程**：
```javascript
collectCurrentImages() {
    const allImages = document.querySelectorAll('img');
    allImages.forEach(img => {
        if (img.src && img.src.startsWith('http')) {
            this.collectedImages.add(img.src);  // 自动去重
        }
    });
}
```

**多源合并去重**：
```javascript
// 合并多个图片源
let allImages = [...mainImages, ...pageImages];
// 使用Set进行最终去重
allImages = [...new Set(allImages)];
```

## 第二层：尺寸筛选

### 图片尺寸检测
**检测技术**：
- 使用Image对象加载图片获取真实尺寸
- 异步检测避免阻塞UI线程
- 支持跨域图片检测

**筛选标准**：
```javascript
const imageOptions = {
    minWidth: 800,      // 最小宽度800px
    minHeight: 800,     // 最小高度800px
    maxWidth: 10000,    // 最大宽度10000px
    maxHeight: 10000,   // 最大高度10000px
    maxCount: 100       // 最大数量限制
};
```

**检测流程**：
```javascript
async detectAndFilterImages(imageUrls, options) {
    for (const imageUrl of imageUrls) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        img.onload = () => {
            const width = img.width;
            const height = img.height;
            
            // 检查尺寸是否符合要求
            const isInRange = width >= minWidth && width <= maxWidth && 
                             height >= minHeight && height <= maxHeight;
            
            if (isInRange) {
                imageInfoList.push({
                    url: imageUrl,
                    width: width,
                    height: height,
                    aspectRatio: (width / height).toFixed(2)
                });
            }
        };
        
        img.src = imageUrl;
    }
}
```

## 第三层：本地去重

### 本地文件检查机制
**检查流程**：
1. 检查商品目录是否存在
2. 读取media.json文件
3. 提取已存在的媒体URL列表
4. 与待下载URL列表进行比对
5. 筛选出需要下载的新文件

### API接口实现
**接口定义**：
```javascript
POST /api/check-existing-media
```

**请求参数**：
```json
{
    "goodsId": "601099521487622",
    "mediaUrls": [
        "https://img.temu.com/image1.jpg",
        "https://img.temu.com/image2.jpg"
    ]
}
```

**响应结果**：
```json
{
    "success": true,
    "message": "本地媒体文件检查完成",
    "existingUrls": ["https://img.temu.com/image1.jpg"],
    "existingCount": 1,
    "totalChecked": 2
}
```

### App端实现
**checkExistingMediaFiles函数**：
```javascript
async function checkExistingMediaFiles(goodsId, mediaUrls) {
    const productDir = path.join(dataDir, 'goods-library', goodsId);
    const mediaJsonPath = path.join(productDir, 'media.json');
    
    // 检查文件是否存在
    if (!fs.existsSync(mediaJsonPath)) {
        return [];
    }
    
    // 读取media.json文件
    const mediaData = JSON.parse(await fsPromises.readFile(mediaJsonPath, 'utf8'));
    
    // 提取已存在的URL
    const existingUrls = [];
    mediaData.media.forEach(media => {
        if (media.url && mediaUrls.includes(media.url)) {
            existingUrls.push(media.url);
        }
    });
    
    return existingUrls;
}
```

### 插件端实现
**filterExistingMedia方法**：
```javascript
async filterExistingMedia(goodsId, mediaList) {
    // 调用App API检查本地media.json文件
    const response = await fetch('http://localhost:3001/api/check-existing-media', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            goodsId: goodsId,
            mediaUrls: mediaList.map(item => item.url)
        })
    });
    
    const result = await response.json();
    const existingUrls = new Set(result.existingUrls || []);
    
    // 筛选出不存在的媒体文件
    const filteredMedia = mediaList.filter(item => {
        return !existingUrls.has(item.url);
    });
    
    return filteredMedia;
}
```

## 性能优化

### 内存优化
- 使用Set数据结构，O(1)查找性能
- 及时清理临时数据，避免内存泄漏
- 分批处理大量媒体文件

### 网络优化
- 本地检查减少不必要的网络请求
- 添加下载间隔，防止服务器限制
- 支持断点续传和错误重试

### 存储优化
- 智能去重，减少重复文件占用空间
- 基于URL精确匹配，确保数据一致性
- 支持增量更新，提高采集效率

## 用户体验

### 进度反馈
```javascript
console.log(`尺寸筛选前媒体数量: ${originalCount}`);
console.log(`尺寸筛选后: ${sizeFilteredCount}`);
console.log(`本地去重后: ${finalCount}`);
console.log(`跳过 ${skippedCount} 个已存在的媒体文件`);
```

### 状态提示
- 显示跳过的文件数量
- 详细的日志记录
- 清晰的错误提示和解决建议

### 容错处理
- 网络错误时自动重试
- 文件错误时跳过损坏文件
- 系统错误时完善的日志记录

## 技术优势

### 高效性
- 三层筛选机制，精确控制下载内容
- 本地去重避免重复下载，节省带宽和时间
- 异步处理不阻塞用户界面

### 准确性
- 基于URL精确匹配，确保数据一致性
- 严格的尺寸要求，保证媒体文件质量
- 完善的错误处理机制

### 可扩展性
- 模块化设计，易于维护和扩展
- 标准化的API接口，支持功能增强
- 灵活的配置选项，适应不同需求

## 使用场景

### 初次采集
- 完整的媒体文件下载
- 建立本地media.json索引

### 增量更新
- 检查新增的媒体文件
- 跳过已存在的文件
- 快速完成采集任务

### 批量采集
- 支持多个商品的批量处理
- 统一的去重机制
- 高效的资源利用

这套媒体文件去重机制确保了采集系统的高效性、准确性和用户体验，是采集功能的核心技术支撑。
